Programming with binders using RepLib
=====================================

XXX introduction needs work

*Names* are the bane of every language designer XXX: important and
unavoidable, yet annoying to deal with and surprisingly tricky to get
right.

RepLib includes a flexible and powerful library for programming with
binders, built on top of RepLib's generic programming framework.  It
makes programming with binders easy and painless.

This literate Haskell tutorial will walk you through the basics of
using the library.

The untyped lambda calculus
---------------------------

Let's start by writing a simple untyped lambda calculus
interpreter. This will illustrate XXX

**Preliminaries**

First, we need to enable lots of wonderful GHC extensions:

> {-# LANGUAGE MultiParamTypeClasses
>            , TemplateHaskell
>            , ScopedTypeVariables
>            , FlexibleInstances
>            , FlexibleContexts
>            , UndecidableInstances
>   #-}

The only one that should really worry you is `UndecidableInstances`.
Sadly, this is necessary in order to typecheck the code generated by
RepLib; but rest assured that the instances generated by RepLib *are*
decidable; it's just that GHC can't prove it.

Now for some imports: 

> import Generics.RepLib
> import Generics.RepLib.Bind.LocallyNameless

We import the RepLib library as well as the locally nameless
implementation of the binding library.  RepLib also provides a nominal
version in `Generics.RepLib.Bind.Nominal`.  At the moment these are
simply two different implementations providing (essentially) the same
interface.  The locally nameless version is more mature, but you are
welcome to experiment with using the nominal version in its place.

Some other imports we'll need for this particular example:

> import Control.Applicative
> import Control.Arrow
>
> import Control.Monad.Trans.Maybe
>
> import Text.Parsec hiding ((<|>))
> import qualified Text.Parsec.Token as P
> import Text.Parsec.Language (haskellDef)

**Representing terms**

We now declare a `Term` data type to represent lambda calculus terms.

> data Term = Var (Name Term)
>           | App Term Term
>           | Lam (Bind (Name Term) Term)
>   deriving Show

The `App` constructor is straightforward, but let's look at the other two
constructors in detail.

First, The `Var` constructor holds a `Name Term`.  `Name` is an
abstract type for representing names provided by RepLib.  `Name`s are
indexed by the sorts of things to which they can refer.  Here, a
variable is simply a name for some `Term`, so we use the type `Name
Term`.

Lambdas are where names are *bound*, so we use the special `Bind` type
also provided by RepLib.  Somthing of type `Bind p b` represents a
pair consisting of a *pattern* `p` and a *body* `b`.  The pattern may
bind names which occur in `b`.  Here is where the power of generic
programming comes into the picture: we may use (almost) any types at
all as patterns and bodies, and RepLib will be able to handle it with
very little extra guidance from us.

In this particular case, a lambda simply binds a single name, so the
pattern is just a `Name Term`, and the body is just another `Term`.

Now we tell RepLib to automatically derive a bunch of
behind-the-scenes, boilerplate instances for `Term`:

> $(derive [''Term])

Almost done, there are just a couple more things we need to do.
First, we make `Term` an instance of `Alpha`, which provides most of
the methods we will need for working with the variables and binders
within `Term`s.

> instance Alpha Term

What, no method definitions?  Nope!  In this case (and in most cases)
the default implementations, written in terms of those instances we
had RepLib derive for us, work just fine.  But in special situations
it's possible to override specific methods in the `Alpha` class with
our own implementations.

We only need to provide one more thing: a `Subst Term Term`
instance. (In general, an instance for `Subst b a` means that we can
use the `subst` function to substitute things of type `b` for `Name`s
occurring in things of type `a`.)  The only method we must implement
ourselves is `isvar`, which has the type

    isvar :: a -> Maybe (Name b, b -> a)

The documentation for `isvar` states "If the argument is a variable,
return its name and a function to generate a substituted term. Return
`Nothing` for non-variable arguments."  Even the most sophisticated
generic programming library can't read our minds: we have to tell it
which values of our data type are variables (*i.e.* things that can be
substituted for).  For `Term` this is not too hard:

> instance Subst Term Term where
>   isvar (Var v) = Just (v, id)
>   isvar _       = Nothing

That's all!

**Trying things out**

OK, now what can we do with this?  First, we define some convenient
helper functions:

> lam :: String -> Term -> Term
> lam x t = Lam $ bind (string2Name x) t
>
> var :: String -> Term
> var = Var . string2Name

Notice that `string2Name` allows us to create a `Name` from a
`String`, and `bind` allows us to construct bindings.

We can test things out at the `ghci` prompt like so:

    *Main> lam "x" (lam "y" (var "x"))
    Lam (<x> Lam (<y> Var 1@0))

XXX more here about de Bruijn indices

We can check that substitution works as it should. Substituting for
`x` in a term where `x` does not occur free has no effect:

    *Main> subst (string2Name "x") (var "z") (lam "x" (var "x"))
    Lam (<x> Var 0@0)
    
If `x` does occur free, the substitution takes place as expected:

    *Main> subst (string2Name "x") (var "z") (lam "y" (var "x"))
    Lam (<y> Var z)

Finally, substitution is capture-avoiding:

    *Main> subst (string2Name "x") (var "y") (lam "y" (var "x"))
    Lam (<y> Var y)

It may look at first glance like `y` has been incorrectly captured, but
the fact that it has a *name* means it is free: if it had been
captured we would see `Lam (<y> Var 0@0)`.


<!--
isValue (App _ _) = False
isValue _         = True

done :: Monad m => MaybeT m a
done = MaybeT $ return Nothing

instance (Functor m, LFresh m) => LFresh (MaybeT m) where
  lfresh    = MaybeT . fmap Just . lfresh
  avoid nms = MaybeT . avoid nms . runMaybeT

step :: (Functor m, LFresh m) => Term -> MaybeT m Term
step (Var _) = done
step (Lam _) = done
step (App (Lam b) t2) =
  lunbind b $ \(x,t1) ->
    return (subst x t2 t1)
step (App t1 t2) =
      App <$> step t1 <*> pure t2
  <|> App <$> pure t1 <*> step t2

tc :: Monad m => (a -> MaybeT m a) -> (a -> m a)
tc f a = do
  ma' <- runMaybeT (f a)
  case ma' of
    Just a' -> tc f a'
    Nothing -> return a

eval :: Term -> Term
eval x = runReader (tc step x) (0::Integer)

-- Some example terms

nm = string2Name

idT = Lam (bind (nm "y") (Var (nm "y")))

foo = Lam (bind (nm "z") (Var (nm "y")))

trueT  = Lam (bind (nm "x") (Lam (bind (nm "y") (Var (nm "x")))))
-- falseT = Lam (bind (nm "x") (Lam (bind (nm "x") (Var (nm "x")))))
-- above doesn't work like I would expect!

falseT = Lam (bind (nm "x") (Lam (bind (nm "y") (Var (nm "y")))))

-- A small parser for Terms
lexer = P.makeTokenParser haskellDef

parens = P.parens lexer
var    = P.identifier lexer
op     = P.symbol lexer

parseTerm = parseAtom `chainl1` (pure App)

parseAtom = parens parseTerm
         <|> (Var . string2Name <$> var)
         <|> Lam <$> (bind <$> (op "\\" *> (string2Name <$> var))
                           <*> (op "." *> parseTerm))

runTerm :: String -> Either ParseError Term
runTerm = (id +++ eval) . parse parseTerm ""

{- example, 2 + 3 = 5:

  *Main> runTerm "(\\m. \\n. \\s. \\z. m s (n s z)) (\\s. \\z. s (s z)) (\\s. \\z. s (s (s z))) s z"
  Right (App (Var s) (App (Var s) (App (Var s) (App (Var s) (App (Var s) (Var z))))))

-}
-->