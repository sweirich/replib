Programming with binders using RepLib
=====================================

*Names* are the bane of every language implementation: they play an
unavoidable, central role, yet are tedious to deal with and surprisingly
tricky to get right.

RepLib includes a flexible and powerful library for programming with
names and binders, which makes programming with binders easy and
painless.  Built on top of RepLib's generic programming framework, it
does a lot of work behind the scenes to provide you with a seamless,
"it just works" experience.

This literate Haskell tutorial will walk you through the basics of
using the library.

The untyped lambda calculus
---------------------------

Let's start by writing a simple untyped lambda calculus
interpreter. This will illustrate XXX

**Preliminaries**

First, we need to enable lots of wonderful GHC extensions:

> {-# LANGUAGE MultiParamTypeClasses
>            , TemplateHaskell
>            , ScopedTypeVariables
>            , FlexibleInstances
>            , FlexibleContexts
>            , UndecidableInstances
>   #-}

The only one that should really worry you is `UndecidableInstances`.
Sadly, this is necessary in order to typecheck the code generated by
RepLib. Rest assured, however, that the instances generated by RepLib
*are* decidable; it's just that GHC can't prove it.

Now for some imports: 

> import Generics.RepLib
> import Generics.RepLib.Bind.LocallyNameless

We import the RepLib library as well as the locally nameless
implementation of the binding library.  (RepLib also provides a nominal
version in `Generics.RepLib.Bind.Nominal`.  At the moment these are
simply two different implementations providing essentially the same
interface.  The locally nameless version is more mature, but you are
welcome to experiment with using the nominal version in its place.)

Some other imports we'll need for this particular example:

XXX do we need all these?

> import Control.Applicative
> import Control.Arrow
>
> import Control.Monad.Trans.Maybe
>
> import Text.Parsec hiding ((<|>))
> import qualified Text.Parsec.Token as P
> import Text.Parsec.Language (haskellDef)

**Representing terms**

We now declare a `Term` data type to represent lambda calculus terms.

> data Term = Var (Name Term)
>           | App Term Term
>           | Lam (Bind (Name Term) Term)
>   deriving Show

The `App` constructor is straightforward, but the other two
constructors are worth looking at in detail.

First, the `Var` constructor holds a `Name Term`.  `Name` is an
abstract type for representing names provided by RepLib.  `Name`s are
indexed by the sorts of things to which they can refer (or more
precisely, the sorts of things which can be substituted for them).
Here, a variable is simply a name for some `Term`, so we use the type
`Name Term`.

Lambdas are where names are *bound*, so we use the special `Bind` type
also provided by RepLib.  Somthing of type `Bind p b` represents a
pair consisting of a *pattern* `p` and a *body* `b`.  The pattern may
bind names which occur in `b`.  Here is where the power of generic
programming comes into play: we may use (almost) any types at all as
patterns and bodies, and RepLib will be able to handle it with very
little extra guidance from us.

In this particular case, a lambda simply binds a single name, so the
pattern is just a `Name Term`, and the body is just another `Term`.

Now we tell RepLib to automatically derive a bunch of
behind-the-scenes, boilerplate instances for `Term`:

> $(derive [''Term])

There are just a couple more things we need to do.  First, we make
`Term` an instance of `Alpha`, which provides most of the methods we
will need for working with the variables and binders within `Term`s.

> instance Alpha Term

What, no method definitions?  Nope!  In this case (and in most cases)
the default implementations, written in terms of those generic
instances we had RepLib derive for us, work just fine.  But in special
situations it's possible to override specific methods in the `Alpha`
class with our own implementations.

We only need to provide one more thing: a `Subst Term Term`
instance. In general, an instance for `Subst b a` means that we can
use the `subst` function to substitute things of type `b` for `Name`s
occurring in things of type `a`.  The only method we must implement
ourselves is `isvar`, which has the type

    isvar :: a -> Maybe (Name b, b -> a)

The documentation for `isvar` states "If the argument is a variable,
return its name and a function to generate a substituted term. Return
`Nothing` for non-variable arguments."  Even the most sophisticated
generic programming library can't read our minds: we have to tell it
which values of our data type are variables (*i.e.* things that can be
substituted for).  For `Term` this is not hard:

> instance Subst Term Term where
>   isvar (Var v) = Just (v, id)
>   isvar _       = Nothing

That's all!

**Trying things out**

Now that we've got the necessary preliminaries set up, what can we do
with this?  First, let's define some convenient helper functions:

> lam :: String -> Term -> Term
> lam x t = Lam $ bind (string2Name x) t
>
> var :: String -> Term
> var = Var . string2Name

Notice that `string2Name` allows us to create a `Name` from a
`String`, and `bind` allows us to construct bindings.

We can test things out at the `ghci` prompt like so:

    *Main> lam "x" (lam "y" (var "x"))
    Lam (<x> Lam (<y> Var 1@0))

The `1@0` is a *de Bruijn index*, which refers to the 0th variable of
the 1st (counting outwards from 0) enclosing binding site; that is, to
`x`.  Recall that the left-hand side of a `Bind` can be an arbitrary
data structure potentially containing multiple names (a *pattern*),
like a pair or a list; hence the need for the index after the `@`.  Of
course, in this particular example we only ever bind one name at once,
so the index after the `@` will always be zero.

We can check that substitution works as we expect. Substituting for
`x` in a term where `x` does not occur free has no effect:

    *Main> subst (string2Name "x") (var "z") (lam "x" (var "x"))
    Lam (<x> Var 0@0)
    
If `x` does occur free, the substitution takes place as expected:

    *Main> subst (string2Name "x") (var "z") (lam "y" (var "x"))
    Lam (<y> Var z)

Finally, substitution is capture-avoiding:

    *Main> subst (string2Name "x") (var "y") (lam "y" (var "x"))
    Lam (<y> Var y)

It may look at first glance like `y` has been incorrectly captured, but
the fact that it has a *name* means it is free: if it had been
captured we would see `Lam (<y> Var 0@0)`.

**Evaluation**

The first thing we want to do is write an evaluator for our lambda
calculus.

<!--
isValue (App _ _) = False
isValue _         = True

done :: Monad m => MaybeT m a
done = MaybeT $ return Nothing

instance (Functor m, LFresh m) => LFresh (MaybeT m) where
  lfresh    = MaybeT . fmap Just . lfresh
  avoid nms = MaybeT . avoid nms . runMaybeT

step :: (Functor m, LFresh m) => Term -> MaybeT m Term
step (Var _) = done
step (Lam _) = done
step (App (Lam b) t2) =
  lunbind b $ \(x,t1) ->
    return (subst x t2 t1)
step (App t1 t2) =
      App <$> step t1 <*> pure t2
  <|> App <$> pure t1 <*> step t2

tc :: Monad m => (a -> MaybeT m a) -> (a -> m a)
tc f a = do
  ma' <- runMaybeT (f a)
  case ma' of
    Just a' -> tc f a'
    Nothing -> return a

eval :: Term -> Term
eval x = runReader (tc step x) (0::Integer)

-- Some example terms

nm = string2Name

idT = Lam (bind (nm "y") (Var (nm "y")))

foo = Lam (bind (nm "z") (Var (nm "y")))

trueT  = Lam (bind (nm "x") (Lam (bind (nm "y") (Var (nm "x")))))
-- falseT = Lam (bind (nm "x") (Lam (bind (nm "x") (Var (nm "x")))))
-- above doesn't work like I would expect!

falseT = Lam (bind (nm "x") (Lam (bind (nm "y") (Var (nm "y")))))

-- A small parser for Terms
lexer = P.makeTokenParser haskellDef

parens = P.parens lexer
var    = P.identifier lexer
op     = P.symbol lexer

parseTerm = parseAtom `chainl1` (pure App)

parseAtom = parens parseTerm
         <|> (Var . string2Name <$> var)
         <|> Lam <$> (bind <$> (op "\\" *> (string2Name <$> var))
                           <*> (op "." *> parseTerm))

runTerm :: String -> Either ParseError Term
runTerm = (id +++ eval) . parse parseTerm ""

{- example, 2 + 3 = 5:

  *Main> runTerm "(\\m. \\n. \\s. \\z. m s (n s z)) (\\s. \\z. s (s z)) (\\s. \\z. s (s (s z))) s z"
  Right (App (Var s) (App (Var s) (App (Var s) (App (Var s) (App (Var s) (Var z))))))

-}
-->